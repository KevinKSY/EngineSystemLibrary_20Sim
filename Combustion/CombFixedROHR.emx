<?xml version="1.0" encoding="UTF-8"?>
<Document>
 <Icons>
    <Icon size="128" bpp="32" format="png">
<![CDATA[89504e470d0a1a0a0000000d4948445200000080000000800806000000c33e61cb00000006624b474400ff00ff00ffa0bda793000000097048597300000ec400000ec401952b0e1b000002f149444154789ceddde1919a401c40f13f9934201690b4623b3691b46209ced8c0d5601ba225904f3884db5d351771f1bddf4c3e089ccbc0730193c9357ddf87b8bebd7a07f45a06006700700600670070060067007006006700700600670070060067007006006700700600670070060067007006006700700600670070060067007006006700700600670070060067007006006700700600670070df530b9ba6f91511bfe7dd15cda1effb66fcda19002e39030c0e87436c369bb9f6454fb4dd6e63b7db7d5a5e0ca0effbf0bf917b6f5e02e00c00ce4b0044ee3c3a03c019009c01c0790f00e70c00670070c54b4044fef141cbe263a0920c00ce00e07c0c847306803300380380f31e00eee61741735aad56111171b95cfe7a3d1896977ef6d6f6a531a6db97d6fdcbd835aaf612903aa8b965a9e5b9ed4bebc7af4bebbeb2bc36555e028683773e9fafcbdab6bdae1b960fcba6dbe6b62f8d31de7efa9eb9f7ba357e6eec5758dc57c1d303573a90a975f71cf8f136a5f152ef359cfcf3f95c1c7f1c498daaba0718dcfba9c96d77cf417f34a8775565008f7ae5a7acf64ff82dd55e02ee953a01b969599f2d7a0628dd84cd65e9a12d7e068858fe4978a52aff45d0ad31a7eb53dbafd7ebe2fad2188fac6bdb36baae4b6e3bec436e7d0dde6206189fecd4eb67189fd4d4784b38f9110bbf07e8baee7aa0e738e9b58dff3f2c7e06487dc2baaebbfe8978eec9c97dc2c7e3d7acaaaf824fa7d375dc47d60fcb07e3f5d39f298df1d575b97da8c1e2be0ad63c0c00aeaa4b80e6e70c006700700600e73d00848f814a3200380380abf2af83351f6700380380f33110ce1900ce00e00c00ce7b0008bf0a569201c07909802b06b0dfefe3783cceb52f7aa2dc796c529f707f73e8fb9afee6d05c003f22e2e74cfba419f57dff317e9d0c401c3e05c019009c01c019009c01c019009c01c019009c01c019009c01c019009c01c019009c01c019009c01c019009c01c019009c01c019009c01c019009c01c019009c01c019009c01c019009c01c0fd0194355ef3a6c3532b0000000049454e44ae426082]]>
   </Icon>
</Icons>
 <Model version="4.6" build="4.4.1.4356">
    <Sidops>
<![CDATA[ROHR 711.4 256.5specifications active 'ChmelaPhenomenological'	specification 'ChmelaPhenomenological' description '<Information>
 <Description>
    <Version>4.6</Version>
  <LibraryPath>Combustion\CombFixedROHR.emx</LibraryPath>
  <TimeStamp>2016-5-31 00:02:01</TimeStamp>
<IsMainModel>1</IsMainModel>
  <KeepParameterValues>False</KeepParameterValues>
  <AllowLibraryUpdate>True</AllowLibraryUpdate>
  <Configuration>
   <struct>
    <member>
     <name>DocumentationMask</name>
     <value>
      <struct></struct>
     </value>
    </member>
   </struct>
  </Configuration>
 </Description>
</Information>'; type Submodel  ports   signal in pfi;   signal in dphiFlat;   signal in fiinj;   signal in omega;   power out pp;   power out pT;   power out pF;   signal out Comb_state;   signal in pRail;   signal in VCyl; end; icon bg bottom  figures   rectangle 680.9 241.5 741.9 271.5 color 0 fill 15132390;   text 'name' 711.4 256.5 color 0 16;  terminals   pfi 704 232 fixed;   dphiFlat 687.4 232 fixed;   fiinj 721.9 232 fixed;   omega 739.5 232 fixed;   Comb_state 739.5 280 fixed; end; implementation eqconstants	real D_coeff[4,5] = [1.1053E+03,	-3.1164E+01,	1.4274E+00,	-5.2975E-03,	-4.6749E-04;						    -1.3298E+03, 1.4771E+02, -5.4041E+00, -5.5594E-02, 3.5522E-03;						    1.6637E+03, -2.4621E+02, 8.6951E+00, 9.9981E-02, -5.8678E-03;						    -1.0697E+03, 1.6974E+02, -7.6850E+00, 6.4605E-02, 1.4729E-03];parameters	integer global nCyl;	integer global nStroke;	real global hn;//	real global fiinj;	real global mqf_max;	real global fs;	real global S, B, lambdaR, CR;// Englib	string global dll_ICE;//	string dll_fcn_rohr    = 'ice_rohr';//	string dll_icemax    = 'ice_pfimax';//	string hidden dll_fcn_ThDP = 'thdyn_CombGasZach'; // subroutines names in the dll file//	string dll_fcn_rohr = 		'ice_rohr2';	real global wiebe_para[9];	real global Cturb, Cdiss, Crate, Cmode;	real global FComb;		real global P_CR, T_CR, T_f; //Fuel parameters	real global noHole, DHole, Cd;		//injector dimension	 	real global pRailRampUp;		//Pressure rise time in the injector[s]	real global pRailRampDown;		//Pressure rise time in the injector[s]	variables	real phi;	real phi_comb;	real P, F, T;	real fiig;	boolean reset;	real igdel;		real PP[5,1], TT[4,1], P_R, T_R, dCA;	real An;//Area of the nozzle holes	real p_nom, p_inj, dP_inj;	real rho_f, u;		real E_kin_f_diss, dE_kin_f_diss, m_f_inj, Q, dQ;	real kTurb;		real pRailRampUpCA, pRailRampDownCA;	real dV_f_inj, dm_f_inj;initialequations	Comb_state = 0;	// 0: Start of new cycle / 1 : injection started / 2 : start of combustion / 5: end of combustion//	if fiinj > 180 then fiinj = fiinj - 360; end;		fiig = 0;	reset = true;	An = noHole*DHole^2*pi/4;	dE_kin_f_diss = 0;	dm_f_inj = 0;	dQ = 0;	rho_f = 800;	TT[1] = 1;	T_R = T_f / T_CR;	TT[2] = T_R;	TT[3] = TT[2]*T_R;	TT[4] = TT[3]*T_R;	code	P=pp.e; F=pF.e; T=pT.e;	phi = pfi*180/pi mod (nStroke*180);		E_kin_f_diss = resint(dE_kin_f_diss,0,reset,0);	m_f_inj = resint(dm_f_inj,0,reset,0);	Q = resint(dQ,0,reset,0);	if phi > 90*nStroke then 		phi_comb= phi - nStroke*180;  	else		phi_comb = phi;	end;	if phi_comb > fiinj and Comb_state == 0 then		Comb_state = 1;		// mqf = mqf_max * x_lev;		igdel = 180/pi*omega*1e-3*0.0405*exp(5473/T)*(P*1e-5)^(-0.757);				// Calculate the injection profile to be applied		pRailRampUpCA = pRailRampUp*omega*180/pi;		pRailRampDownCA = pRailRampDown*omega*180/pi;				// no combustion if the ignition delay is too much		if igdel > 30 then			Comb_state = 5;		end;				fiig = fiinj + igdel;		reset = false;	else if phi_comb > fiig and Comb_state == 1 then				Comb_state = 2;			else	if phi_comb > fiig + 120 and Comb_state == 2 then						Comb_state = 5;						reset = true;					end;			end;	end;				if phi_comb > -20 and phi_comb < -15 then		Comb_state = 0;	end;				switch Comb_state		case 1 do			PP[1] = 1;				P_R = P / P_CR;				PP[2] = P_R;			PP[3] = PP[2]*P_R;					PP[4] = PP[3]*P_R;	PP[5] = PP[4]*P_R;						rho_f = transpose(D_coeff*PP)*TT;		   dCA = phi_comb - fiinj;		   if dCA <= pRailRampUpCA then				p_nom =  dCA/(pRailRampUpCA);			else				dCA = dCA - pRailRampUpCA;				if dCA <= dphiFlat then	            p_nom = 1;				else					dCA = dCA - dphiFlat;					if dCA <= pRailRampDownCA then               	p_nom = 1 - (dCA)/(pRailRampDownCA);	            else   					p_nom = 0;            	end;				end;        	end; 						dQ = 0;		case 2 do			PP[1] = 1;				P_R = P / P_CR;				PP[2] = P_R;			PP[3] = PP[2]*P_R;					PP[4] = PP[3]*P_R;	PP[5] = PP[4]*P_R;				rho_f = transpose(D_coeff*PP)*TT;		   dCA = phi_comb - fiinj;		   if dCA <= pRailRampUpCA then				p_nom =  dCA/(pRailRampUpCA);			else				dCA = dCA - pRailRampUpCA;				if dCA <= dphiFlat then	            p_nom = 1;				else					dCA = dCA - dphiFlat;					if dCA <= pRailRampDownCA then               	p_nom = 1 - (dCA)/(pRailRampDownCA);	            else   					p_nom = 0;					end;            end;        	end;			if m_f_inj == 0 then				kTurb = 0; 			else				kTurb = Cturb*E_kin_f_diss / (1e-10 + m_f_inj * (1+1/(FComb*fs)));			end;			dQ = Cmode*(180*omega/pi)*(m_f_inj - Q/hn)*exp(Crate*sqrt(kTurb)/(VCyl^0.333));		default do			p_nom = 0;			rho_f = 800;			dQ = 0;	end;		p_inj = pRail * p_nom;	dP_inj = max([0, p_inj - P]);	u = sqrt(2*dP_inj/rho_f); //The velocity of the droplets in the zone	dV_f_inj = u*An*Cd;	dm_f_inj = dV_f_inj * rho_f;	dE_kin_f_diss = 0.5*dm_f_inj*u^2 - Cdiss*E_kin_f_diss;		pp.f= dQ / hn;	pF.f= dQ / hn;	pT.f= dQ;	/*	inarr_pfimax=[time; phi; P];	outarr_pfimax=dll(dll_ICE,dll_icemax, inarr_pfimax);	Pmax=outarr_pfimax[1];Pmax_pfi=outarr_pfimax[2];	p_max = [Pmax;Pmax_pfi];	*/implementation_end;specification_end;	specification 'FixedShapeFixedDurComb'description '<Information> <Description>    <Version>4.5</Version>  <LibraryPath>FlowRestriction\CombROHR.emx</LibraryPath>  <TimeStamp>2015-11-14 17:37:19</TimeStamp><IsMainModel>1</IsMainModel>  <KeepParameterValues>False</KeepParameterValues>  <AllowLibraryUpdate>True</AllowLibraryUpdate>  <Configuration>   <struct>    <member>     <name>DocumentationMask</name>     <value>      <struct></struct>     </value>    </member>   </struct>  </Configuration> </Description></Information>'; type Submodel  ports   signal in pfi;   signal in x_lev;   signal in fiinj;   signal in omega;   power out pp;   power out pT;   power out pF;   signal out Comb_state; end; icon bg bottom  figures   rectangle 683.9 241.5 738.9 271.5 color 0 fill 15132390;   text 'name' 711.4 256.5 color 0 16;  terminals   pfi 704.1 232 fixed;   x_lev 687.4 232 fixed;   fiinj 721.9 232 fixed;   omega 739.6 232 fixed;   Comb_state 739.6 280 fixed; end; implementation eqparameters	integer global nCyl;	integer global nStroke;	real global hn;//	real global fiinj;	real global mqf_max;	real global fs;	real global S, B, lambdaR, CR;// Englib	string global dll_ICE;//	string dll_fcn_rohr    = 'ice_rohr';//	string dll_icemax    = 'ice_pfimax';//	string hidden dll_fcn_ThDP = 'thdyn_CombGasZach'; // subroutines names in the dll file//	string dll_fcn_rohr = 		'ice_rohr2';	real global wiebe_para[9];variables	real phi;	real phi_comb;	real P, F, T;	real dmf;	real mqf;//	real inarr_ROHR[20], outarr_ROHR[13];	real fiig;//	real hidden inarr_pfimax[3], outarr_pfimax[2];//	real hidden inarr_ThermoProp[3], outarr_ThermoProp[13];//	real Pmax, Pmax_pfi;//	real bmepnom, omeganom;//	real eta_i, sfoc;//	real mfPC, mf, Oldmf, OldmfPC;	boolean reset;		real dphi_comb, igdel, dmf_nom;	real yp, ym, yl, yptomp, ymtomm, yltoml, df1dy, df2dy, df3dy;	initialequations	Comb_state = 0;	// 0: Start of new cycle / 1 : injection started / 2 : start of combustion / 5: end of combustion//	if fiinj > 180 then fiinj = fiinj - 360; end;		fiig = 0;	reset = true;	mqf = 0;	dmf = 0;	dphi_comb = wiebe_para[3] + wiebe_para[6];code	P=pp.e; F=pF.e; T=pT.e;	phi = pfi*180/pi mod (nStroke*180);	if phi > 90*nStroke then 		phi_comb= phi - nStroke*180;  	else		phi_comb = phi;	end;	if phi_comb > fiinj and Comb_state == 0 then		Comb_state = 1;		mqf = mqf_max * x_lev;		igdel = 180/pi*omega*1e-3*0.0405*exp(5473/T)*(P*1e-5)^(-0.757);		if igdel > 30 then			Comb_state = 5;		end;		fiig = fiinj + igdel;		reset = false;			else if phi_comb > fiig and phi_comb < fiig + dphi_comb and Comb_state == 1 then				Comb_state = 2;				reset = true;			else	if phi_comb > fiig + dphi_comb and reset == true then						Comb_state = 5;						reset = false;					end;			end;	end;				if phi_comb > -20 and phi_comb < -15 then		Comb_state = 0;		reset = true;	end;				switch Comb_state		case 2 do			yp = max([(phi_comb - fiig) / wiebe_para[4];0]);			ym = max([0;(phi_comb - (fiig + wiebe_para[3]))/wiebe_para[5]]);			yl = max([0;(phi_comb - (fiig + wiebe_para[3]))/wiebe_para[6]]);			yptomp = yp^wiebe_para[7];			ymtomm = ym^wiebe_para[8];			yltoml = yl^wiebe_para[9];			df1dy = 6.9*(wiebe_para[7] + 1)*yptomp*exp(-6.9*yp*yptomp) / wiebe_para[4];			df2dy = 6.9*(wiebe_para[8] + 1)*ymtomm*exp(-6.9*ym*ymtomm) / wiebe_para[5];			df3dy = 6.9*(wiebe_para[9] + 1)*yltoml*exp(-6.9*yl*yltoml) / wiebe_para[6];			dmf_nom = wiebe_para[1]*df1dy + wiebe_para[2]*df2dy + (1-wiebe_para[1] - wiebe_para[2])*df3dy;			dmf = mqf*dmf_nom*omega*180/pi;		default do			dmf = 0;	end;		pp.f=dmf;	pF.f= dmf;	pT.f=dmf*hn;	/*	inarr_pfimax=[time; phi; P];	outarr_pfimax=dll(dll_ICE,dll_icemax, inarr_pfimax);	Pmax=outarr_pfimax[1];Pmax_pfi=outarr_pfimax[2];	p_max = [Pmax;Pmax_pfi];	*/implementation_end;specification_end;	specification 'FixedShapeVarDurComb'description '<Information><Description><Version>4.6</Version><LibraryPath>Combustion\CombFixedROHR.emx</LibraryPath><TimeStamp>2016-3-30 23:27:23</TimeStamp><IsMainModel>1</IsMainModel><KeepParameterValues>False</KeepParameterValues><AllowLibraryUpdate>True</AllowLibraryUpdate><Configuration><struct><member><name>DocumentationMask</name><value><struct></struct></value></member></struct></Configuration></Description></Information>'; type Submodel  ports   signal in pfi;   signal in x_lev;   signal in fiinj;   signal in omega;   power out pp;   power out pT;   power out pF;   signal out Comb_state; end; icon bg bottom  figures   rectangle 680.9 241.5 741.9 271.5 color 0 fill 15132390;   text 'name' 711.4 256.5 color 0 16;  terminals   pfi 704 232 fixed;   x_lev 687.4 232 fixed;   fiinj 721.9 232 fixed;   omega 739.5 232 fixed;   Comb_state 739.5 280 fixed; end; implementation eqparameters	integer global nCyl;	integer global nStroke;	real global hn;//	real global fiinj;	real global mqf_max;	real global fs;	real global S, B, lambdaR, CR;// Englib	string global dll_ICE;//	string dll_fcn_rohr    = 'ice_rohr';//	string dll_icemax    = 'ice_pfimax';//	string hidden dll_fcn_ThDP = 'thdyn_CombGasZach'; // subroutines names in the dll file//	string dll_fcn_rohr = 		'ice_rohr2';	real global wiebe_para[9];variables	real phi;	real phi_comb;	real P, F, T;	real dmf;	real mqf;//	real inarr_ROHR[20], outarr_ROHR[13];	real fiig;//	real hidden inarr_pfimax[3], outarr_pfimax[2];//	real hidden inarr_ThermoProp[3], outarr_ThermoProp[13];//	real Pmax, Pmax_pfi;//	real bmepnom, omeganom;//	real eta_i, sfoc;//	real mfPC, mf, Oldmf, OldmfPC;	boolean reset;	real wiebe3Temp, wiebe4Temp, wiebe5Temp, wiebe6Temp;  // Wiebe parameters related to combustion duration		real dphi_comb, igdel, dmf_nom;	real yp, ym, yl, yptomp, ymtomm, yltoml, df1dy, df2dy, df3dy;	initialequations	Comb_state = 0;	// 0: Start of new cycle / 1 : injection started / 2 : start of combustion / 5: end of combustion//	if fiinj > 180 then fiinj = fiinj - 360; end;		fiig = 0;	reset = true;	mqf = 0;	dmf = 0;	wiebe3Temp = wiebe_para[3];	wiebe4Temp = wiebe_para[4];		wiebe5Temp = wiebe_para[5];	wiebe6Temp = wiebe_para[6];		dphi_comb = wiebe3Temp + wiebe6Temp;code	P=pp.e; F=pF.e; T=pT.e;	phi = pfi*180/pi mod (nStroke*180);	if phi > 90*nStroke then 		phi_comb= phi - nStroke*180;  	else		phi_comb = phi;	end;	if phi_comb > fiinj and Comb_state == 0 then		Comb_state = 1;		mqf = mqf_max * x_lev;		igdel = 180/pi*omega*1e-3*0.0405*exp(5473/T)*(P*1e-5)^(-0.757);		// Vary combustion duration according to amount of injection		wiebe3Temp = 0.6*wiebe_para[3]*(1+0.6667*x_lev);		wiebe4Temp = 0.6*wiebe_para[4]*(1+0.6667*x_lev);		wiebe5Temp = 0.6*wiebe_para[5]*(1+0.6667*x_lev);		wiebe6Temp = 0.6*wiebe_para[6]*(1+0.6667*x_lev);		dphi_comb = wiebe3Temp + wiebe6Temp;		// For constant duration, use following		// dphi_comb = wiebe_para[3] + wiebe_para[6];				// **********************************************************				if igdel > 30 then			Comb_state = 5;		end;		fiig = fiinj + igdel;		reset = false;			else if phi_comb > fiig and phi_comb < fiig + dphi_comb and Comb_state == 1 then				Comb_state = 2;				reset = true;			else	if phi_comb > fiig + dphi_comb and reset == true then						Comb_state = 5;						reset = false;					end;			end;	end;				if phi_comb > -20 and phi_comb < -15 then		Comb_state = 0;		reset = true;	end;				switch Comb_state		case 2 do			yp = max([(phi_comb - fiig) / wiebe4Temp;0]);			ym = max([0;(phi_comb - (fiig + wiebe3Temp))/wiebe5Temp]);			yl = max([0;(phi_comb - (fiig + wiebe3Temp))/wiebe6Temp]);			yptomp = yp^wiebe_para[7];			ymtomm = ym^wiebe_para[8];			yltoml = yl^wiebe_para[9];			df1dy = 6.9*(wiebe_para[7] + 1)*yptomp*exp(-6.9*yp*yptomp) / wiebe4Temp;			df2dy = 6.9*(wiebe_para[8] + 1)*ymtomm*exp(-6.9*ym*ymtomm) / wiebe5Temp;			df3dy = 6.9*(wiebe_para[9] + 1)*yltoml*exp(-6.9*yl*yltoml) / wiebe6Temp;			dmf_nom = wiebe_para[1]*df1dy + wiebe_para[2]*df2dy + (1-wiebe_para[1] - wiebe_para[2])*df3dy;			dmf = mqf*dmf_nom*omega*180/pi;		default do			dmf = 0;	end;		pp.f=dmf;	pF.f= dmf;	pT.f=dmf*hn;	/*	inarr_pfimax=[time; phi; P];	outarr_pfimax=dll(dll_ICE,dll_icemax, inarr_pfimax);	Pmax=outarr_pfimax[1];Pmax_pfi=outarr_pfimax[2];	p_max = [Pmax;Pmax_pfi];	*/implementation_end;specification_end;	specification 'FixedWiebeUserInput'description '<Information> <Description>    <Version>4.6</Version>  <LibraryPath>Combustion\CombFixedROHR.emx</LibraryPath>  <TimeStamp>2016-4-10 09:52:35</TimeStamp><IsMainModel>1</IsMainModel>  <KeepParameterValues>False</KeepParameterValues>  <AllowLibraryUpdate>True</AllowLibraryUpdate>  <Configuration>   <struct>    <member>     <name>DocumentationMask</name>     <value>      <struct></struct>     </value>    </member>   </struct>  </Configuration> </Description></Information>'; type Submodel  ports   signal in pfi;   signal in x_lev;   signal in fiinj;   signal in omega;   power out pp;   power out pT;   power out pF;   signal out Comb_state; end; icon bg bottom  figures   rectangle 680.9 241.5 741.9 271.5 color 0 fill 15132390;   text 'name' 711.4 256.5 color 0 16;  terminals   pfi 704 232 fixed;   x_lev 687.4 232 fixed;   fiinj 721.9 232 fixed;   omega 739.5 232 fixed;   Comb_state 739.5 280 fixed; end; implementation eqparameters	integer global nCyl;	integer global nStroke;	real global hn;//	real global fiinj;	real global mqf_max;	real global fs;	real global S, B, lambdaR, CR;// Englib	string global dll_ICE;//	string dll_fcn_rohr    = 'ice_rohr';//	string dll_icemax    = 'ice_pfimax';//	string hidden dll_fcn_ThDP = 'thdyn_CombGasZach'; // subroutines names in the dll file//	string dll_fcn_rohr = 		'ice_rohr2';variables	real phi;	real phi_comb;	real P, F, T;	real dmf;	real mqf;//	real inarr_ROHR[20], outarr_ROHR[13];	real fiig;//	real hidden inarr_pfimax[3], outarr_pfimax[2];//	real hidden inarr_ThermoProp[3], outarr_ThermoProp[13];//	real Pmax, Pmax_pfi;//	real bmepnom, omeganom;//	real eta_i, sfoc;//	real mfPC, mf, Oldmf, OldmfPC;	boolean reset;	real wiebe3Temp, wiebe4Temp, wiebe5Temp, wiebe6Temp;  // Wiebe parameters related to combustion duration		real dphi_comb, igdel, dmf_nom;	real yp, ym, yl, yptomp, ymtomm, yltoml, df1dy, df2dy, df3dy;	real global wiebe_para[9];	real pAtInj, TAtInj, phiInj;	initialequations	Comb_state = 0;	// 0: Start of new cycle / 1 : injection started / 2 : start of combustion / 5: end of combustion//	if fiinj > 180 then fiinj = fiinj - 360; end;		fiig = 0;	reset = true;	mqf = 0;	dmf = 0;	wiebe3Temp = wiebe_para[3];	wiebe4Temp = wiebe_para[4];		wiebe5Temp = wiebe_para[5];	wiebe6Temp = wiebe_para[6];		dphi_comb = wiebe3Temp + wiebe6Temp;	code	P=pp.e; F=pF.e; T=pT.e;	phi = pfi*180/pi mod (nStroke*180);	if phi > nStroke*90 then 		phi_comb= phi - nStroke*180;  	else		phi_comb = phi;	end;	if phi_comb > fiinj and Comb_state == 0 then		Comb_state = 1;		mqf = mqf_max * x_lev;		igdel = 180/pi*omega*1e-3*0.0405*exp(5473/T)*(P*1e-5)^(-0.757);		pAtInj = P;		TAtInj = T;		phiInj = phi_comb;		// Vary combustion duration according to amount of injection		wiebe3Temp = 0.6*wiebe_para[3]*(1+0.6667*x_lev);		wiebe4Temp = 0.6*wiebe_para[4]*(1+0.6667*x_lev);		wiebe5Temp = 0.6*wiebe_para[5]*(1+0.6667*x_lev);		wiebe6Temp = 0.6*wiebe_para[6]*(1+0.6667*x_lev);		dphi_comb = wiebe3Temp + wiebe6Temp;		// For constant duration, use following		// dphi_comb = wiebe_para[3] + wiebe_para[6];				// **********************************************************				if igdel > 30 then			Comb_state = 5;		end;		fiig = fiinj + igdel;		reset = false;			else if phi_comb > fiig and phi_comb < fiig + dphi_comb and Comb_state == 1 then				Comb_state = 2;				reset = true;			else	if phi_comb > fiig + dphi_comb and reset == true then						Comb_state = 5;						reset = false;					end;			end;	end;				if phi_comb > -20 and phi_comb < -15 then		Comb_state = 0;		reset = true;	end;				switch Comb_state		case 2 do			yp = max([(phi_comb - fiig) / wiebe4Temp;0]);			ym = max([0;(phi_comb - (fiig + wiebe3Temp))/wiebe5Temp]);			yl = max([0;(phi_comb - (fiig + wiebe3Temp))/wiebe6Temp]);			yptomp = yp^wiebe_para[7];			ymtomm = ym^wiebe_para[8];			yltoml = yl^wiebe_para[9];			df1dy = 6.9*(wiebe_para[7] + 1)*yptomp*exp(-6.9*yp*yptomp) / wiebe4Temp;			df2dy = 6.9*(wiebe_para[8] + 1)*ymtomm*exp(-6.9*ym*ymtomm) / wiebe5Temp;			df3dy = 6.9*(wiebe_para[9] + 1)*yltoml*exp(-6.9*yl*yltoml) / wiebe6Temp;			dmf_nom = wiebe_para[1]*df1dy + wiebe_para[2]*df2dy + (1-wiebe_para[1] - wiebe_para[2])*df3dy;			dmf = mqf*dmf_nom*omega*180/pi;		default do			dmf = 0;	end;		pp.f=dmf;	pF.f= dmf;	pT.f=dmf*hn;	/*	inarr_pfimax=[time; phi; P];	outarr_pfimax=dll(dll_ICE,dll_icemax, inarr_pfimax);	Pmax=outarr_pfimax[1];Pmax_pfi=outarr_pfimax[2];	p_max = [Pmax;Pmax_pfi];	*/implementation_end;specification_end;end;]]>
  </Sidops>
</Model>
</Document>
